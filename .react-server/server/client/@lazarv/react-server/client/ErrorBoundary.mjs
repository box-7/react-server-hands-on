import{jsxs as f,jsx as d,Fragment as B}from"react/jsx-runtime";import{createContext as g,useContext as h,useState as C,useMemo as x,Component as R,createElement as S,isValidElement as v,useEffect as w}from"react";import{F as y,a as T,u as p,P as b}from"../../../../@lazarv/react-server.D1Kr91kI.mjs";import"node:async_hooks";import"node:worker_threads";import"picocolors";const E=g(null);function z(){const t=h(E),[r,e]=C({error:null,hasError:!1}),o=x(()=>({resetBoundary:()=>{t.resetErrorBoundary(),e({error:null,hasError:!1})},showBoundary:n=>e({error:n,hasError:!0})}),[t.resetErrorBoundary]);if(r.hasError)throw r.error;return o}const c={didCatch:!1,error:null};class k extends R{constructor(r){super(r),this.resetErrorBoundary=this.resetErrorBoundary.bind(this),this.state=c}static getDerivedStateFromError(r){return{didCatch:!0,error:r}}async resetErrorBoundary(...r){const{error:e}=this.state;e!==null&&(await this.props.onReset?.({args:r,reason:"imperative-api",error:e,resetErrorBoundary:this.resetErrorBoundary}),typeof e?.digest!="string"&&this.setState(c))}componentDidCatch(r,e){this.props.onError?.(r,e)}componentDidUpdate(r,e){const{didCatch:o}=this.state,{resetKeys:n}=this.props;if(o&&e.error!==null&&F(r.resetKeys,n))if(typeof this.props.onReset=="function"){const a=this.props.onReset({next:n,prev:r.resetKeys,reason:"keys"});typeof a?.then=="function"?a.then(()=>{this.setState(c)}):this.setState(c)}else this.setState(c)}render(){const{children:r,fallbackRender:e,FallbackComponent:o,fallback:n}=this.props,{didCatch:a,error:s}=this.state;s?.message==="Redirect"&&s?.digest.startsWith("Location=")&&(s.redirectTo=s.digest.slice(9));let i=r;if(a){const u={error:s,resetErrorBoundary:this.resetErrorBoundary};if(delete s.stack,typeof e=="function")i=e(u);else if(o)i=S(o,u);else if(n===null||v(n))i=n;else throw s}return d(E.Provider,{value:{didCatch:a,error:s,resetErrorBoundary:this.resetErrorBoundary},children:i})}}function F(t=[],r=[]){return t.length!==r.length||t.some((e,o)=>!Object.is(e,r[o]))}function K({FallbackComponent:t,fallbackRender:r,...e}){const{outlet:o}=h(y),n=p(),{navigate:a}=n,{error:s}=e,{redirectTo:i}=s;return w(()=>{i&&a(i,{outlet:o,external:o!==b})},[i,a,o]),i?null:f(B,{children:[t&&typeof t=="function"?d(t,{...e}):t,r?.(e)]})}function O({error:t}){if(t)throw t;return null}function G({component:t,render:r,onReset:e,global:o,children:n,...a}){const{outlet:s}=h(y),{resourceKey:i,error:u}=h(T),{invalidate:m}=p();return f(k,{...a,onReset:async l=>{typeof l.error?.digest=="string"&&await m(s),e?.(l)},fallbackRender:l=>d(K,{FallbackComponent:t,fallbackRender:r,...l}),children:[d(O,{error:u}),n]},`${s}_${i}`)}export{k as ErrorBoundary,G as default,z as useErrorBoundary};
